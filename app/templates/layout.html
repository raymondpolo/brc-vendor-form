<!DOCTYPE html>
<html lang="en" class="antialiased">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <title>{{ title }} - BRC Vendor Form</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdn.ckeditor.com/ckeditor5/41.4.2/super-build/ckeditor.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://unpkg.com/tributejs"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <link rel="stylesheet" href="https://unpkg.com/tribute.css" />

    <style>
        /* Custom Base Styles & Component Refinements */
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>

    <script>
        // Custom Tailwind CSS Configuration
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        brand: {
                            light: '#a5b4fc',
                            DEFAULT: '#4f46e5',
                            dark: '#3730a3',
                        },
                        surface: {
                            DEFAULT: '#ffffff',
                            secondary: '#f8fafc',
                            subtle: '#f1f5f9',
                        },
                        text: {
                            DEFAULT: '#334155',
                            secondary: '#64748b',
                            subtle: '#94a3b8',
                        },
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };
    </script>
</head>
<body class="bg-surface-secondary" data-auth="{{ 1 if current_user.is_authenticated else 0 }}">
    <a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:z-50 focus:px-4 focus:py-2 focus:bg-white focus:text-brand-dark focus:shadow-lg">
        Skip to main content
    </a>

    <div x-data="{ isSidebarOpen: window.innerWidth > 1024 }" @keydown.escape.window="isSidebarOpen = false" class="relative min-h-screen lg:flex">

        {% if current_user.is_authenticated %}
            <div class="fixed bottom-4 right-4 z-40 lg:hidden">
                <a href="{{ url_for('main.new_request') }}" class="flex items-center justify-center w-14 h-14 bg-brand rounded-full text-white shadow-lg hover:bg-brand-dark transition-colors">
                    <svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                    </svg>
                </a>
            </div>

            {% include 'partials/_sidebar.html' %}

            <div x-show="isSidebarOpen" @click="isSidebarOpen = false" class="fixed inset-0 z-20 bg-black bg-opacity-50 lg:hidden" x-transition:enter="transition-opacity ease-linear duration-300" x-transition:enter-start="opacity-0" x-transition:leave="transition-opacity ease-linear duration-300" x-transition:leave-end="opacity-0" style="display: none;"></div>
        {% endif %}

        <div class="flex-1 flex flex-col overflow-hidden">
            {% if current_user.is_authenticated %}
                {% include 'partials/_header.html' %}
            {% endif %}

            <main id="main-content" class="flex-1 overflow-y-auto p-4 md:p-6 lg:p-8">
                {# Back button is rendered selectively via a partial in templates that need it #}
                {% with messages = get_flashed_messages(with_categories=true) %}
                    {% if messages %}
                        {% for category, message in messages %}
                            <div class="p-4 mb-4 text-sm rounded-lg {% if category == 'success' %} bg-green-100 text-green-800 {% elif category == 'info' %} bg-blue-100 text-blue-800 {% else %} bg-red-100 text-red-700 {% endif %}">
                                {{ message }}
                            </div>
                        {% endfor %}
                    {% endif %}
                {% endwith %}
                {% block content %}{% endblock %}
            </main>
        </div>
    </div>

    <div id="notification-toast" class="fixed bottom-5 right-5 bg-green-500 text-white p-4 rounded-lg shadow-lg hidden">
        <p id="notification-toast-text"></p>
    </div>

    <script>
        // Time Update Function (Modified for Denver Timezone and New Format)
        function updateTime() {
            const timeEl = document.getElementById('current-time');
            if (timeEl) {
                const now = new Date();
                // Options for Denver timezone and specific format
                const options = {
                    timeZone: 'America/Denver', // Set timezone to Denver
                    weekday: 'long',    // "Saturday"
                    year: 'numeric',    // "2025"
                    month: 'long',     // "October"
                    day: 'numeric',     // "18"
                    hour: '2-digit',    // "hh"
                    minute: '2-digit',  // "mm"
                    second: '2-digit',  // "ss"
                    hour12: true       // Use AM/PM, adjust if 24hr needed
                };
                // Format the date and time string
                timeEl.textContent = now.toLocaleString('en-US', options);
            }
        }
        setInterval(updateTime, 1000); // Update every second
        updateTime(); // Initial call to display time immediately

        // --- Keep Socket.IO Connection ---
        document.addEventListener('DOMContentLoaded', function () {
            const socket = io({ transports: ['websocket'] });
            socket.on('connect', () => console.log('Connected to WebSocket server.'));
            socket.on('notification', function(data) {
                const toast = document.getElementById('notification-toast');
                const toastText = document.getElementById('notification-toast-text');
                toastText.innerHTML = `<a href="${data.link}" class="hover:underline">${data.text}</a>`;
                toast.classList.remove('hidden');
                setTimeout(() => toast.classList.add('hidden'), 5000);
            });
            socket.on('connect_error', (err) => console.error('Connection Error:', err));
        });

        // --- Keep PUSH NOTIFICATION SCRIPT (runs only for authenticated users) ---
        if (document.body && document.body.dataset && document.body.dataset.auth === '1') {
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                window.addEventListener('load', () => {
                    // Incremented version to v=6
                    navigator.serviceWorker.register('/service-worker.js?v=6')
                        .then(registration => {
                            console.log('ServiceWorker registration successful with scope: ', registration.scope);
                            // Pass the registration to the permission/subscription flow so we can subscribe even
                            // when the service worker's scope doesn't control the page.
                            askPermissionAndSubscribe(registration);
                        })
                        .catch(err => {
                            console.log('ServiceWorker registration failed: ', err);
                        });
                });
            }
        }

        // --- Keep Push Helper Functions ---
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/\-/g, '+')
                .replace(/_/g, '/');

            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);

            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        function askPermissionAndSubscribe(registration) {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    console.log('DEBUG SUB JS: Notification permission granted.');
                    // Fetch the VAPID public key from the server at runtime to avoid templating/quoting issues
                    fetch('/vapid_public_key', { credentials: 'same-origin', headers: { 'Accept': 'application/json' } })
                        .then(async resp => {
                            const contentType = resp.headers.get('content-type') || '';
                            const text = await resp.text();
                            // If we got HTML back (e.g., a login page), log the raw response for debugging
                            if (!contentType.includes('application/json')) {
                                console.error('DEBUG SUB JS: /vapid_public_key returned non-JSON. Possible redirect to login. Response text starts with:', text.slice(0, 200));
                                throw new Error('Non-JSON response from /vapid_public_key');
                            }
                            try {
                                const data = JSON.parse(text || '{}');
                                return data;
                            } catch (e) {
                                console.error('DEBUG SUB JS: Error parsing JSON from /vapid_public_key. Raw response:', text);
                                throw e;
                            }
                        })
                        .then(data => {
                            if (data && data.success && data.vapidPublicKey) {
                                subscribeUser(registration, data.vapidPublicKey);
                            } else {
                                console.error('DEBUG SUB JS: Could not retrieve VAPID public key from server', data);
                            }
                        })
                        .catch(err => console.error('DEBUG SUB JS: Error fetching VAPID public key:', err));
                } else {
                    console.log('DEBUG SUB JS: Notification permission denied.');
                }
            });
        }

        function subscribeUser(registration, vapidPublicKey) {
            console.log("DEBUG SUB JS: VAPID Public Key from server:", vapidPublicKey);

            if (!vapidPublicKey) {
                console.error("DEBUG SUB JS: VAPID_PUBLIC_KEY is EMPTY. Cannot subscribe. Check environment variables and server endpoint.");
                return;
            }

            let applicationServerKey;
            try {
                applicationServerKey = urlBase64ToUint8Array(vapidPublicKey.trim());
                console.log("DEBUG SUB JS: VAPID key successfully converted to Uint8Array.");
            } catch (e) {
                console.error("DEBUG SUB JS: ERROR converting VAPID key (is it valid?):", e);
                return;
            }

            // Prefer using the registration returned by navigator.serviceWorker.register()
            // If that's not provided, fall back to navigator.serviceWorker.ready
            const doSubscribe = (reg) => {
                console.log("DEBUG SUB JS: Using ServiceWorkerRegistration to call pushManager.subscribe...");
                try {
                    console.log("DEBUG SUB JS: ServiceWorker is ready. Calling pushManager.subscribe...");
                        // Diagnostic: log any existing subscription
                        reg.pushManager.getSubscription().then(existingSub => {
                            console.log('DEBUG SUB JS: Existing subscription for registration:', existingSub);
                        }).catch(err => console.warn('DEBUG SUB JS: getSubscription() failed:', err));

                        // Diagnostic: log applicationServerKey details
                        try {
                            console.log('DEBUG SUB JS: applicationServerKey byteLength =', applicationServerKey.byteLength);
                            const view = new Uint8Array(applicationServerKey);
                            console.log('DEBUG SUB JS: applicationServerKey sample bytes (first 10):', Array.from(view.slice(0,10)));
                        } catch (err) {
                            console.warn('DEBUG SUB JS: Could not inspect applicationServerKey:', err);
                        }

                        console.log('DEBUG SUB JS: navigator.userAgent:', navigator.userAgent);
                        reg.pushManager.subscribe({
                            userVisibleOnly: true,
                            applicationServerKey: applicationServerKey
                        })
                        .then(subscription => {
                        console.log('DEBUG SUB JS: Browser push subscription successful:', subscription);
                        console.log('DEBUG SUB JS: Sending subscription to /subscribe...');
                        fetch('/subscribe', {
                            method: 'POST',
                            credentials: 'same-origin', // important: send cookies (session + CSRF linkage)
                            body: JSON.stringify(subscription),
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json',
                                'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                            }
                        })
                        .then(async response => {
                            console.log('DEBUG SUB JS: Received response from /subscribe:', response.status, response.url);
                            const text = await response.text();
                            // Try to parse JSON, otherwise log raw text for debugging
                            try {
                                const data = JSON.parse(text || '{}');
                                if (response.ok) {
                                    if (data.success) console.log('DEBUG SUB JS: Server successfully saved subscription.');
                                    else console.error('DEBUG SUB JS: Server reported failure in saving subscription:', data);
                                    return data;
                                }
                                throw new Error(data.message || 'Failed to save subscription on server.');
                            } catch (e) {
                                console.error('DEBUG SUB JS: Could not parse JSON response from /subscribe. Raw response:', text);
                                throw e;
                            }
                        })
                        .catch(err => {
                            console.error('DEBUG SUB JS: Error sending subscription to /subscribe:', err);
                        });
                    })
                    .catch(err => {
                        console.error('DEBUG SUB JS: Failed to subscribe the user with pushManager:', err);
                        // If AbortError, try again using the ArrayBuffer backing the key (some mobile
                        // implementations are picky about the type of the key).
                        try {
                            const isAbort = err && err.name === 'AbortError';
                            if (isAbort) {
                                console.log('DEBUG SUB JS: AbortError detected â€” retrying using applicationServerKey.buffer');
                                const keyBuffer = applicationServerKey instanceof ArrayBuffer ? applicationServerKey : applicationServerKey.buffer;
                                reg.pushManager.subscribe({
                                    userVisibleOnly: true,
                                    applicationServerKey: keyBuffer
                                })
                                .then(sub2 => {
                                    console.log('DEBUG SUB JS: Retry subscribe successful (used ArrayBuffer):', sub2);
                                    // send to server
                                    fetch('/subscribe', {
                                        method: 'POST',
                                        credentials: 'same-origin',
                                        body: JSON.stringify(sub2),
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'Accept': 'application/json',
                                            'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                                        }
                                    })
                                    .then(async response => {
                                        console.log('DEBUG SUB JS: Received response from /subscribe (retry):', response.status, response.url);
                                        const text = await response.text();
                                        try {
                                            const data = JSON.parse(text || '{}');
                                            if (response.ok) {
                                                if (data.success) console.log('DEBUG SUB JS: Server successfully saved subscription (retry).');
                                                else console.error('DEBUG SUB JS: Server reported failure in saving subscription (retry):', data);
                                                return data;
                                            }
                                            throw new Error(data.message || 'Failed to save subscription on server.');
                                        } catch (e) {
                                            console.error('DEBUG SUB JS: Could not parse JSON response from /subscribe (retry). Raw response:', text);
                                            throw e;
                                        }
                                    })
                                    .catch(err2 => console.error('DEBUG SUB JS: Error sending subscription to /subscribe (retry):', err2));
                                })
                                .catch(errRetry => {
                                    console.error('DEBUG SUB JS: Retry subscribe also failed:', errRetry);
                                });
                                return;
                            }
                        } catch (ex) {
                            console.error('DEBUG SUB JS: Error during retry logic:', ex);
                        }
                    });
                } catch (e) {
                    console.error('DEBUG SUB JS: Exception while calling pushManager.subscribe:', e);
                }
            };

            if (registration) {
                doSubscribe(registration);
            } else {
                console.log("DEBUG SUB JS: Waiting for navigator.serviceWorker.ready as fallback...");
                navigator.serviceWorker.ready.then(reg => doSubscribe(reg)).catch(err => console.error('DEBUG SUB JS: navigator.serviceWorker.ready promise FAILED:', err));
            }
        }

        // Client-side helper to render tag badges consistently from a comma-separated string or array
        function renderTags(tags) {
            if (!tags) return '';
            // normalize to array
            let arr = Array.isArray(tags) ? tags : String(tags).split(',').map(t => t.trim()).filter(Boolean);
            return arr.map(tag => {
                let classes = 'inline-flex items-center justify-start px-2 py-0.5 text-xs font-semibold rounded-full mr-2 ';
                if (['Approved','Completed'].includes(tag)) classes += 'bg-green-100 text-green-800';
                else if (['Declined','Quote Declined'].includes(tag)) classes += 'bg-red-100 text-red-800';
                else if (tag === 'Go-back') classes += 'bg-blue-100 text-blue-800';
                else if (tag === 'Follow-up needed') classes += 'bg-purple-100 text-purple-800';
                else classes += 'bg-yellow-100 text-yellow-800';
                return `<span class="${classes}">${tag}</span>`;
            }).join('');
        }
        // Global toast helper
        function showToast(message, type='success', timeout=4000) {
            const toast = document.getElementById('notification-toast');
            const toastText = document.getElementById('notification-toast-text');
            toastText.textContent = message || '';
            // set background based on type
            toast.classList.remove('bg-green-500','bg-blue-500','bg-red-500');
            if (type === 'success') toast.classList.add('bg-green-500');
            else if (type === 'info') toast.classList.add('bg-blue-500');
            else toast.classList.add('bg-red-500');
            toast.classList.remove('hidden');
            clearTimeout(toast._hideTimer);
            toast._hideTimer = setTimeout(() => toast.classList.add('hidden'), timeout);
        }

        // Universal AJAX handler: intercept forms and links with data-ajax="true"
        document.addEventListener('DOMContentLoaded', () => {
            // Intercept forms
            document.body.addEventListener('submit', async (ev) => {
                const form = ev.target;
                if (!(form instanceof HTMLFormElement)) return;
                if (form.dataset.ajax !== 'true') return;
                ev.preventDefault();
                try {
                    const action = form.action || window.location.href;
                    const method = (form.method || 'POST').toUpperCase();
                    const formData = new FormData(form);
                    const headers = {};
                    // If this is not a multipart form, send as URLSearchParams for convenience
                    let body = formData;
                    if (!form.enctype || form.enctype === 'application/x-www-form-urlencoded') {
                        body = new URLSearchParams();
                        for (const [k,v] of formData.entries()) body.append(k, v);
                    }
                    // Ensure cookies (session) and CSRF token are sent for same-origin requests
                    const headersWithCsrf = Object.assign({}, headers);
                    try {
                        const meta = document.querySelector('meta[name="csrf-token"]');
                        if (meta && !headersWithCsrf['X-CSRFToken']) headersWithCsrf['X-CSRFToken'] = meta.getAttribute('content');
                    } catch (e) { /* ignore */ }
                    const resp = await fetch(action, { method, body, credentials: 'same-origin', headers: headersWithCsrf });
                    const text = await resp.text();
                    let json;
                    try { json = JSON.parse(text || '{}'); } catch (e) { json = null; }
                    if (json && json.message) showToast(json.message, json.success ? 'success' : 'info');
                    if (json && json.tags) {
                        const container = document.getElementById('tags-container');
                        if (container) container.innerHTML = json.tags;
                    }
                    // allow non-json response fallback: show text in toast if present
                    if (!json && text) showToast(text.slice(0, 300), 'info');
                } catch (err) {
                    console.error('AJAX form submit failed', err);
                    showToast('Request failed', 'error');
                }
            });

            // Intercept clicks on elements with data-ajax="true" and data-method
            document.body.addEventListener('click', async (ev) => {
                // If the click originates from within a form element, let the form's submit handler handle it.
                if (ev.target.closest && ev.target.closest('form')) return; // do not intercept clicks inside forms
                const el = ev.target.closest('[data-ajax="true"]');
                if (!el) return;
                // Only intercept anchor-like elements; prevent interfering with buttons that submit forms
                const isAnchorLike = el.tagName === 'A' || el.hasAttribute('data-href') || el.hasAttribute('href');
                if (!isAnchorLike) return;
                ev.preventDefault();
                const href = el.getAttribute('href') || el.dataset.href || el.action;
                const method = (el.dataset.method || 'GET').toUpperCase();
                try {
                    const opts = { method, credentials: 'same-origin' };
                    // Ensure CSRF token header included for same-origin fetches
                    try {
                        const meta = document.querySelector('meta[name="csrf-token"]');
                        if (meta) opts.headers = Object.assign({}, opts.headers || {}, { 'X-CSRFToken': meta.getAttribute('content') });
                    } catch (e) { /* ignore */ }
                    const resp = await fetch(href, opts);
                    const text = await resp.text();
                    let json;
                    try { json = JSON.parse(text || '{}'); } catch (_) { json = null; }
                    if (json && json.message) showToast(json.message, json.success ? 'success' : 'info');
                    if (json && json.tags) {
                        const container = document.getElementById('tags-container');
                        if (container) container.innerHTML = json.tags;
                    }
                } catch (err) {
                    console.error('AJAX link failed', err);
                    showToast('Request failed', 'error');
                }
            });
        });

        // goBack helper: prefer the last list URL stored in sessionStorage, then history.back(), then fall back to dashboard
        function goBack() {
            try {
                const last = sessionStorage.getItem('lastListUrl');
                if (last && last !== window.location.href) {
                    window.location.href = last;
                    return;
                }
            } catch (e) {
                console.warn('Could not access sessionStorage for lastListUrl', e);
            }
            // fallback to history.back if available and same-origin referrer
            try {
                if (document.referrer && new URL(document.referrer).origin === window.location.origin) {
                    window.history.back();
                    return;
                }
            } catch (e) {
                // ignore
            }
            // Final fallback: go to All Requests
            window.location.href = '{{ url_for("main.all_requests") }}';
        }
        
        // Ensure CSRF token is present in dynamic/admin user forms that may be generated client-side
        (function() {
            function injectCsrf(csrfValue, form) {
                if (!csrfValue || !form) return false;
                try {
                    if (form.querySelector('input[name="csrf_token"]')) return true;
                    const inp = document.createElement('input');
                    inp.type = 'hidden';
                    inp.name = 'csrf_token';
                    inp.value = csrfValue;
                    form.appendChild(inp);
                    return true;
                } catch (e) {
                    return false;
                }
            }

            function shouldTargetForm(form) {
                if (!form || form.method.toUpperCase() !== 'POST') return false;
                const action = form.getAttribute('action') || '';
                // Some templates bind the action attribute via data-binding; also inspect dataset.action
                const dataAction = form.dataset && form.dataset.action ? form.dataset.action : '';
                return action.includes('/admin/user/') || dataAction.includes('/admin/user/');
            }

            function scanAndInject(csrfValue) {
                const forms = Array.from(document.querySelectorAll('form'));
                forms.forEach(f => {
                    try {
                        if (shouldTargetForm(f)) injectCsrf(csrfValue, f);
                    } catch (e) { /* ignore */ }
                });
            }

            document.addEventListener('DOMContentLoaded', function () {
                const csrfMeta = document.querySelector('meta[name="csrf-token"]');
                const csrfValue = csrfMeta ? csrfMeta.getAttribute('content') : null;
                if (!csrfValue) return;

                // Initial pass
                scanAndInject(csrfValue);

                // Observe for dynamically added forms (Alpine x-for, etc.) and inject as they appear
                const observer = new MutationObserver((mutations) => {
                    for (const m of mutations) {
                        if (m.type === 'childList' && m.addedNodes && m.addedNodes.length) {
                            m.addedNodes.forEach(node => {
                                try {
                                    if (node.nodeType !== Node.ELEMENT_NODE) return;
                                    if (node.tagName === 'FORM' && shouldTargetForm(node)) {
                                        injectCsrf(csrfValue, node);
                                    } else if (node.querySelectorAll) {
                                        const nested = node.querySelectorAll('form');
                                        nested.forEach(f => { if (shouldTargetForm(f)) injectCsrf(csrfValue, f); });
                                    }
                                } catch (e) { /* ignore individual failures */ }
                            });
                        }
                    }
                });

                observer.observe(document.body, { childList: true, subtree: true });

                // Also inject before form submit as a last-resort safety in case injection missed timing
                document.body.addEventListener('submit', function (ev) {
                    try {
                        const form = ev.target;
                        if (shouldTargetForm(form) && !form.querySelector('input[name="csrf_token"]')) {
                            injectCsrf(csrfValue, form);
                        }
                    } catch (e) { /* ignore */ }
                }, true);
            });
        })();
    </script>
</body>
</html>                     